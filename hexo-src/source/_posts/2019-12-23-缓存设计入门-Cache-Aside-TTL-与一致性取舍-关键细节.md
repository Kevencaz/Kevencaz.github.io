---
title: 缓存设计入门：Cache Aside、TTL 与一致性取舍｜关键细节
date: 2019-12-23 07:20:22
tags:
- 缓存
- 后端
---

> 缓存不是越多越好，边界和失效策略才是关键。

<!-- more -->

## 开篇

这篇文章面向多环境交付团队，从协作视角深入拆解缓存设计入门。当前定位为「入门」阶段，核心目标是建立基本概念与最小闭环。我们会从实际场景出发，结合具体代码示例，把关键知识点拆解为可落地的行动步骤。衡量标准：交付周期/回滚次数。

## 问题拆解

缓存是后端系统中最常用的性能优化手段，但也是最容易出问题的地方。"缓存一时爽，一致性火葬场"这句话虽然夸张，但确实反映了现实。很多线上事故的根因都是缓存数据与数据库不一致，或者缓存雪崩导致数据库被打垮。理解缓存的设计模式和失效策略，是后端工程师的必修课。

数据库的 QPS 上限通常在几千到几万，而 Redis 这样的缓存系统可以轻松达到十万级。对于读多写少的场景，缓存能将响应时间从几十毫秒降到亚毫秒级。但缓存引入了数据一致性的挑战：当数据库更新了，缓存里的旧数据怎么办？不同的业务场景对一致性的容忍度不同，这决定了你应该选择哪种缓存策略。

## 解决方案

最常用的缓存模式是 Cache Aside（旁路缓存）：

读流程：先查缓存，命中则直接返回；未命中则查数据库，将结果写入缓存后返回。
写流程：先更新数据库，再删除缓存（而不是更新缓存）。

为什么是"删除"而不是"更新"缓存？因为在并发场景下，两个写请求可能导致缓存中存储了旧值。删除缓存让下一次读请求自然回源，保证最终一致性。

TTL（Time To Live）是缓存的安全网。即使删除操作失败，TTL 到期后缓存也会自动失效。建议根据业务容忍度设置 TTL：用户信息 5-15 分钟，配置数据 1-5 分钟，热点数据 30-60 秒。

对于一致性要求更高的场景，可以使用延迟双删：先删缓存，更新数据库，等待一小段时间后再删一次缓存，覆盖可能的并发读回填。

## 代码实战

在业务增长带来的容量压力的实际场景中，下面的代码模式非常实用：

```js
// Cache Aside 读流程
async function getUser(id) {
  const key = `user:${id}`;
  let data = await redis.get(key);
  if (data) return JSON.parse(data); // 缓存命中

  data = await db.query('SELECT * FROM users WHERE id = ?', [id]);
  if (data) {
    // 回填缓存，TTL 5分钟 + 随机偏移防雪崩
    const ttl = 300 + Math.floor(Math.random() * 60);
    await redis.set(key, JSON.stringify(data), 'EX', ttl);
  }
  return data;
}

// Cache Aside 写流程
async function updateUser(id, updates) {
  await db.query('UPDATE users SET ? WHERE id = ?', [updates, id]);
  await redis.del(`user:${id}`); // 先更新库，再删缓存
}
```

## 工程化落地

实际落地时，还需要考虑缓存穿透（查询不存在的数据）、缓存击穿（热点 Key 过期瞬间大量请求打到数据库）和缓存雪崩（大量 Key 同时过期）。应对方案分别是：布隆过滤器或缓存空值、互斥锁或永不过期+异步更新、TTL 加随机偏移量。监控方面，重点关注缓存命中率（目标 > 95%）和回源 QPS。

对于多环境交付团队来说，建议从最小可行方案开始，先跑通核心流程，再逐步完善边界处理和监控告警。不要试图一次性做到完美，建立基本概念与最小闭环才是当前阶段的重点。

## 避坑清单

最常见的错误是"先删缓存再更新数据库"，这在并发下几乎必然导致脏数据。其次是 TTL 设置过长，导致数据不一致的窗口期太大。还有一种情况是缓存了过多的冷数据，占用内存但命中率很低——缓存应该只存热数据。

## 总结与展望

本文从协作视角梳理了缓存设计入门在入门阶段的关键实践。核心指标是交付周期/回滚次数，最大风险是规范缺失造成返工。希望这些经验能帮你少走弯路，在业务增长带来的容量压力中更从容地推进。
