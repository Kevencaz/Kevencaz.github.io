---
title: HTTP 从建立连接到返回响应：一次请求的完整旅程｜执行路线
date: 2022-02-22 01:21:11
tags:
- HTTP
- 网络
---

> 把链路拆成阶段看，性能瓶颈会非常清晰。

<!-- more -->

## 开篇

这篇文章面向2-5 人小团队，从稳定性视角深入拆解HTTP 从建立连接到返回响应。当前定位为「进阶」阶段，核心目标是稳定可复用，开始处理边界。我们会从实际场景出发，结合具体代码示例，把关键知识点拆解为可落地的行动步骤。衡量标准：SLA/MTTR/错误率。

## 问题拆解

当你在浏览器地址栏输入一个 URL 并按下回车，背后发生的事情远比你想象的复杂。从 DNS 解析到 TCP 握手，从 TLS 协商到 HTTP 请求发送，再到服务器处理、响应传输、浏览器渲染——每一个环节都可能成为性能瓶颈。理解这条完整链路，是做性能优化的基础。

很多开发者在排查"页面加载慢"的问题时，第一反应是优化后端接口。但实际上，网络层面的耗时往往占了总时间的大头。DNS 解析可能花 50-200ms，TCP 握手需要一个 RTT，TLS 1.2 还要额外两个 RTT。如果服务器在海外，光是网络往返就可能超过 500ms。不了解完整链路，优化就像蒙着眼睛射箭。

## 解决方案

一次完整的 HTTP 请求可以拆分为以下阶段：

1. DNS 解析：浏览器查询域名对应的 IP 地址，依次检查浏览器缓存、系统缓存、路由器缓存、ISP DNS 服务器。
2. TCP 连接：通过三次握手建立可靠连接。如果是 HTTPS，还需要 TLS 握手协商加密参数。
3. 请求发送：浏览器构造 HTTP 请求报文（方法、路径、头部、Body），通过已建立的连接发送。
4. 服务器处理：Web 服务器接收请求，经过路由、中间件、业务逻辑、数据库查询等处理。
5. 响应传输：服务器将响应数据分块传输回客户端。
6. 浏览器渲染：解析 HTML、构建 DOM、加载 CSS/JS、布局绘制。

每个阶段都有对应的优化手段：DNS 预解析（dns-prefetch）、连接复用（keep-alive）、HTTP/2 多路复用、CDN 就近访问、Gzip/Brotli 压缩、浏览器缓存策略等。

## 代码实战

在已有系统的重构期的实际场景中，下面的代码模式非常实用：

```bash
# 查看完整请求各阶段耗时
curl -w "DNS:      %{time_namelookup}s\nTCP:      %{time_connect}s\nTLS:      %{time_appconnect}s\nTTFB:     %{time_starttransfer}s\nTotal:    %{time_total}s\nSize:     %{size_download} bytes\n" \
     -o /dev/null -s https://example.com

# DNS 预解析 (HTML 中添加)
# <link rel="dns-prefetch" href="//api.example.com">
# <link rel="preconnect" href="//cdn.example.com">
```

## 工程化落地

用 Chrome DevTools 的 Network 面板可以看到每个请求的 Timing 分解。curl 的 -w 参数也能输出各阶段耗时。建议在关键页面设置 Performance Budget，用 Lighthouse CI 在流水线中自动检测。对于 API 接口，在网关层记录 TTFB（Time To First Byte）作为核心监控指标。

对于2-5 人小团队来说，建议从最小可行方案开始，先跑通核心流程，再逐步完善边界处理和监控告警。不要试图一次性做到完美，稳定可复用，开始处理边界才是当前阶段的重点。

## 避坑清单

常见误区包括：只关注接口响应时间而忽略网络传输耗时；没有开启 HTTP/2 导致队头阻塞；缓存策略设置不当导致每次都回源；CDN 配置了但缓存命中率很低；以及忽略了 DNS 解析时间——特别是使用了多个第三方域名的页面。

## 总结与展望

本文从稳定性视角梳理了HTTP 从建立连接到返回响应在进阶阶段的关键实践。核心指标是SLA/MTTR/错误率，最大风险是缺少降级兜底引发雪崩。希望这些经验能帮你少走弯路，在已有系统的重构期中更从容地推进。
