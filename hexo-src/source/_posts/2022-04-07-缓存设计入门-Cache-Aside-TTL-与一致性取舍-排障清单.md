---
title: 缓存设计入门：Cache Aside、TTL 与一致性取舍｜排障清单
date: 2022-04-07 00:51:41
tags:
- 缓存
- 后端
---

> 缓存不是越多越好，边界和失效策略才是关键。

<!-- more -->

## 开篇定位

这篇面向有专职运维支持的团队，从协作视角拆解缓存设计入门，目标是让协作可追踪、可回滚。

深度定位：进阶，重点是稳定可复用，开始处理边界。

我们先统一指标（交付周期/回滚次数），再把动作拆成可验证步骤。

## 背景

常见问题不是“没有缓存”，而是“缓存命中后数据错了”。一致性与可回退是设计缓存时的核心。

在线上问题频发的阶段阶段，最容易忽视的是规范缺失造成返工，先对齐度量口径能减少返工。

## 方法拆解

- 读：先查缓存，未命中再查数据库并回填。
- 写：先写库，再删缓存（或延迟双删）。
- 用 TTL + 版本号兜底，避免脏数据无限期存在。

## 深度推进

- 补齐指标与监控
- 处理异常与回滚
- 形成可复用模板

## 关键指标

- 核心指标：交付周期/回滚次数
- 目标：让协作可追踪、可回滚
- 验证方式：上线后 7 天回看趋势

## 执行提示

- 逐步引入自动化检查
- 灰度发布并演练回滚
- 沉淀复盘文档

## 示例

~~~js
const key = `user:${id}`;
let data = await cache.get(key);
if (!data) {
  data = await db.getUser(id);
  await cache.set(key, data, { ttl: 300 });
}
return data;
~~~

## 常见误区

- 热数据写入顺序不当导致脏读
- TTL 过长放大错误影响
- 缓存雪崩未做降级
- 规范缺失造成返工
- 稳定优先于新增能力
- 不要在无监控下扩范围

## 工具与资料

- 压测：k6/Locust
- 日志：ELK/ClickHouse
- 链路：OpenTelemetry

## Checklist

- 为热点 Key 设置合理 TTL
- 缓存失败时有降级路径
- 监控命中率与回源比例
- 深度目标：方案可复用且可回滚
- 节奏：紧急修复热更新
